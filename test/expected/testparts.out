create schema partest;
set datestyle = 'ISO';
create extension pgparts with schema partest;
create table sometbl (
    id serial primary key,
    day date not null,
    data text);
select * from partest.info('sometbl', '2014-09-15');
     state     | partition 
---------------+-----------
 unpartitioned | 
(1 row)

select partest.create_for('sometbl', '2014-09-15');
ERROR:  the table sometbl has not been partitioned yet
HINT:  You should call partest.setup('sometbl').
-- We don't know this schema
select partest.setup('sometbl'::regclass, 'day', 'derp', '{3}');
ERROR:  partitioning schema derp on type date not known
select partest.setup('sometbl'::regclass, 'day', 'monthly', '{3}');
 setup 
-------
 
(1 row)

select * from partest.info('sometbl', '2014-09-15');
  state  | partition 
---------+-----------
 missing | 
(1 row)

-- Setup works once
select partest.setup('sometbl'::regclass, 'day', 'monthly', '{3}');
ERROR:  the table sometbl is already partitioned
HINT:  Use partest.create_for('sometbl', VALUE) to create new partitions on the table.
-- This insert fails
insert into sometbl values (100, '2014-09-15', 'first');
ERROR:  no partition available on table sometbl
HINT:  You should call partest.create_for('sometbl', '2014-09-15').
select * from only sometbl;
 id | day | data 
----+-----+------
(0 rows)

select partest.create_for('sometbl', '2014-09-15');
   create_for   
----------------
 sometbl_201407
(1 row)

select * from partest.info('sometbl', '2014-09-15');
  state  |   partition    
---------+----------------
 present | sometbl_201407
(1 row)

-- Insert
insert into sometbl values (100, '2014-09-15', 'first');
select * from only sometbl;
 id | day | data 
----+-----+------
(0 rows)

select * from only sometbl_201407;
 id  |    day     | data  
-----+------------+-------
 100 | 2014-09-15 | first
(1 row)

-- Update, no partition change
update sometbl set day = '2014-8-15' where id = 100;
select * from only sometbl;
 id | day | data 
----+-----+------
(0 rows)

select * from only sometbl_201407;
 id  |    day     | data  
-----+------------+-------
 100 | 2014-08-15 | first
(1 row)

-- Update to fail partition
update sometbl set day = '2014-10-15' where id = 100;
ERROR:  partition on table sometbl missing for day = '2014-10-15'
HINT:  You should call partest.create_for('sometbl', '2014-10-15').
CONTEXT:  SQL statement "insert into sometbl values (new.*)"
PL/pgSQL function sometbl_partition_update() line 4 at SQL statement
select * from only sometbl;
 id | day | data 
----+-----+------
(0 rows)

select * from only sometbl_201407;
 id  |    day     | data  
-----+------------+-------
 100 | 2014-08-15 | first
(1 row)

-- Create the missing partition and try again
select partest.create_for('sometbl', '2014-10-15');
   create_for   
----------------
 sometbl_201410
(1 row)

update sometbl set day = '2014-10-15' where id = 100;
select * from only sometbl;
 id | day | data 
----+-----+------
(0 rows)

select * from only sometbl_201407;
 id | day | data 
----+-----+------
(0 rows)

select * from only sometbl_201410;
 id  |    day     | data  
-----+------------+-------
 100 | 2014-10-15 | first
(1 row)

-- Detach the partition removes it from writing
insert into sometbl values (104, '2014-07-10', 'third');
select partest.detach_for('sometbl', '2014-07-10');
   detach_for   
----------------
 sometbl_201407
(1 row)

-- Partition is there but removed from the base table
select * from sometbl where day = '2014-07-10';
 id | day | data 
----+-----+------
(0 rows)

select * from sometbl_201407 where day = '2014-07-10';
 id  |    day     | data  
-----+------------+-------
 104 | 2014-07-10 | third
(1 row)

-- Trigger has been maintained
insert into sometbl values (105, '2014-07-10', 'fourth');
ERROR:  partition on table sometbl missing for day = '2014-07-10'
HINT:  You should call partest.create_for('sometbl', '2014-07-10').
insert into sometbl values (106, '2014-10-10', 'fifth');
-- Idempotent
select partest.detach_for('sometbl', '2014-07-10');
   detach_for   
----------------
 sometbl_201407
(1 row)

-- Can't create the same partition again
select partest.create_for('sometbl', '2014-07-10');
ERROR:  the partition sometbl_201407 exists but is detached
HINT:  You can attach it back using partest.attach_for('sometbl', '2014-07-10').
-- But can attach it back
select partest.attach_for('sometbl', '2014-07-10');
   attach_for   
----------------
 sometbl_201407
(1 row)

insert into sometbl values (105, '2014-07-10', 'fourth');
select * from sometbl where day = '2014-07-10' order by id;
 id  |    day     |  data  
-----+------------+--------
 104 | 2014-07-10 | third
 105 | 2014-07-10 | fourth
(2 rows)

-- Idempotent
select partest.attach_for('sometbl', '2014-07-10');
   attach_for   
----------------
 sometbl_201407
(1 row)

-- Constraints and indexes
create table constr1 (id1 int, id2 int, primary key (id1, id2));
insert into constr1 values (1,2), (3,4);
create table constr2 (
    id serial primary key,
    date date not null,
    fid1 int, fid2 int,
    foreign key (fid1, fid2) references constr1 (id1, id2),
    uint int check (uint > 0),
    unique (uint),
    iint int,
    c circle,
    exclude using gist (c with &&)
);
create index constr2_iint on constr2(iint);
create unique index somename on constr2(iint) where id > 0;
create unique index taken on constr2(iint) where id > 1;
create table constr2_201409_taken ();
select partest.setup('constr2', 'date', 'monthly', '{1}');
 setup 
-------
 
(1 row)

select partest.create_for('constr2', '2014-09-01');
   create_for   
----------------
 constr2_201409
(1 row)

select conname, pg_get_constraintdef(oid, true) from pg_constraint
where conrelid = 'constr2_201409'::regclass
order by conname;
            conname             |                       pg_get_constraintdef                       
--------------------------------+------------------------------------------------------------------
 constr2_201409_c_excl          | EXCLUDE USING gist (c WITH &&)
 constr2_201409_fid1_fkey       | FOREIGN KEY (fid1, fid2) REFERENCES constr1(id1, id2)
 constr2_201409_partition_check | CHECK ('2014-09-01'::date <= date AND date < '2014-10-01'::date)
 constr2_201409_pkey            | PRIMARY KEY (id)
 constr2_201409_uint_key        | UNIQUE (uint)
 constr2_uint_check             | CHECK (uint > 0)
(6 rows)

select pg_get_indexdef(indexrelid) from pg_index
where indrelid = 'constr2_201409'::regclass
order by 1;
                                         pg_get_indexdef                                         
-------------------------------------------------------------------------------------------------
 CREATE INDEX constr2_201409_c_excl ON constr2_201409 USING gist (c)
 CREATE INDEX constr2_201409_iint ON constr2_201409 USING btree (iint)
 CREATE UNIQUE INDEX constr2_201409_pkey ON constr2_201409 USING btree (id)
 CREATE UNIQUE INDEX constr2_201409_somename ON constr2_201409 USING btree (iint) WHERE (id > 0)
 CREATE UNIQUE INDEX constr2_201409_taken1 ON constr2_201409 USING btree (iint) WHERE (id > 1)
 CREATE UNIQUE INDEX constr2_201409_uint_key ON constr2_201409 USING btree (uint)
(6 rows)

-- Ownership
create user u1;
create user u2;
create user u3;
create schema testown;
grant create, usage on schema testown to public;
set session authorization u1;
create table testown.t1 (id int primary key, date date);
grant insert on table testown.t1 to u2;
grant select on table testown.t1 to u2 with grant option;
create table testown.t2 (id int primary key, date date);
revoke truncate on table testown.t2 from u1;
reset session authorization;
set session authorization u2;
grant select on table testown.t1 to u3;
grant select on table testown.t1 to public;
create table testown.t3 (id int primary key, date date);
reset session authorization;
alter table testown.t3 owner to u3;
create or replace function comp_acls(src regclass, tgt regclass,
   out src_acl aclitem, out tgt_acl aclitem, out match bool)
returns setof record
language sql as
$$
    with src as (select unnest(relacl) as src_acl from pg_class
        where oid = $1
        order by 1::text),
    tgt as (select unnest(relacl) as tgt_acl from pg_class
        where oid = $2
        order by 1::text)
    select *, src_acl = tgt_acl
    from src full outer join tgt on src_acl = tgt_acl
    order by 1::text;
$$;
select partest.setup('testown.t1', 'date', 'monthly', '{1}');
 setup 
-------
 
(1 row)

select partest.create_for('testown.t1', '2014-09-01');
    create_for     
-------------------
 testown.t1_201409
(1 row)

select * from comp_acls('testown.t1', 'testown.t1_201409');
    src_acl    |    tgt_acl    | match 
---------------+---------------+-------
 u1=arwdDxt/u1 | u1=arwdDxt/u1 | t
 u2=ar*/u1     | u2=ar*/u1     | t
 u3=r/u2       | u3=r/u2       | t
 =r/u2         | =r/u2         | t
(4 rows)

select usename from pg_user u join pg_class c on c.relowner = u.usesysid
where c.oid = 'testown.t1'::regclass;
 usename 
---------
 u1
(1 row)

select partest.setup('testown.t2', 'date', 'monthly', '{1}');
 setup 
-------
 
(1 row)

select partest.create_for('testown.t2', '2014-09-01');
    create_for     
-------------------
 testown.t2_201409
(1 row)

select * from comp_acls('testown.t2', 'testown.t2_201409');
   src_acl    |   tgt_acl    | match 
--------------+--------------+-------
 u1=arwdxt/u1 | u1=arwdxt/u1 | t
(1 row)

select usename from pg_user u join pg_class c on c.relowner = u.usesysid
where c.oid = 'testown.t1'::regclass;
 usename 
---------
 u1
(1 row)

select partest.setup('testown.t3', 'date', 'monthly', '{1}');
 setup 
-------
 
(1 row)

select partest.create_for('testown.t3', '2014-09-01');
    create_for     
-------------------
 testown.t3_201409
(1 row)

select * from comp_acls('testown.t3', 'testown.t3_201409');
 src_acl | tgt_acl | match 
---------+---------+-------
(0 rows)

select usename from pg_user u join pg_class c on c.relowner = u.usesysid
where c.oid = 'testown.t1'::regclass;
 usename 
---------
 u1
(1 row)

set client_min_messages to 'error';
drop schema testown cascade;
reset client_min_messages;
drop user u1;
drop user u2;
drop user u3;
-- Monthly timestamp
create table monthts (id serial primary key, ts timestamp);
select partest.setup('monthts', 'ts', 'monthly', '{1}');
 setup 
-------
 
(1 row)

select partest.create_for('monthts', '2014-09-01');
   create_for   
----------------
 monthts_201409
(1 row)

select partest.create_for('monthts', '2014-10-01');
   create_for   
----------------
 monthts_201410
(1 row)

insert into monthts(ts) values ('2014-08-31T23:59:59.999');
ERROR:  partition on table monthts missing for ts = '2014-08-31 23:59:59.999'
HINT:  You should call partest.create_for('monthts', '2014-08-31 23:59:59.999').
insert into monthts(ts) values ('2014-09-01');
insert into monthts(ts) values ('2014-09-30T23:59:59.999');
insert into monthts(ts) values ('2014-10-01');
insert into monthts(ts) values ('2014-10-31T23:59:59.999');
insert into monthts(ts) values ('2014-11-01');
ERROR:  partition on table monthts missing for ts = '2014-11-01 00:00:00'
HINT:  You should call partest.create_for('monthts', '2014-11-01 00:00:00').
-- Monthly timestamptz
create table monthtstz (id serial primary key, ts timestamptz);
select partest.setup('monthtstz', 'ts', 'monthly', '{1}');
 setup 
-------
 
(1 row)

select partest.create_for('monthtstz', '2014-09-01');
    create_for    
------------------
 monthtstz_201409
(1 row)

select partest.create_for('monthtstz', '2014-10-01');
    create_for    
------------------
 monthtstz_201410
(1 row)

insert into monthtstz(ts) values ('2014-08-31T23:59:59.999');
ERROR:  partition on table monthtstz missing for ts = '2014-08-31 23:59:59.999-07'
HINT:  You should call partest.create_for('monthtstz', '2014-08-31 23:59:59.999-07').
insert into monthtstz(ts) values ('2014-09-01');
insert into monthtstz(ts) values ('2014-09-30T23:59:59.999');
insert into monthtstz(ts) values ('2014-10-01');
insert into monthtstz(ts) values ('2014-10-31T23:59:59.999');
insert into monthtstz(ts) values ('2014-11-01');
ERROR:  partition on table monthtstz missing for ts = '2014-11-01 00:00:00-07'
HINT:  You should call partest.create_for('monthtstz', '2014-11-01 00:00:00-07').
-- Daily date
create table days (id serial primary key, ts timestamptz);
select partest.setup('days', 'ts', 'daily', '{1}');
 setup 
-------
 
(1 row)

select partest.create_for('days', '2014-09-01');
  create_for   
---------------
 days_20140901
(1 row)

select partest.create_for('days', '2014-09-02');
  create_for   
---------------
 days_20140902
(1 row)

insert into days(ts) values ('2014-08-31T23:59:59.999');
ERROR:  partition on table days missing for ts = '2014-08-31 23:59:59.999-07'
HINT:  You should call partest.create_for('days', '2014-08-31 23:59:59.999-07').
insert into days(ts) values ('2014-09-01');
insert into days(ts) values ('2014-09-01T23:59:59.999');
insert into days(ts) values ('2014-09-02');
insert into days(ts) values ('2014-09-02T23:59:59.999');
insert into days(ts) values ('2014-09-03');
ERROR:  partition on table days missing for ts = '2014-09-03 00:00:00-07'
HINT:  You should call partest.create_for('days', '2014-09-03 00:00:00-07').
-- Weeks starting on Saturdays
create table weeks (id serial primary key, ts date);
select partest.setup('weeks', 'ts', 'daily', '{7,6}');
 setup 
-------
 
(1 row)

select partest.create_for('weeks', '2014-09-12');
   create_for   
----------------
 weeks_20140906
(1 row)

select partest.create_for('weeks', '2014-09-13');
   create_for   
----------------
 weeks_20140913
(1 row)

insert into weeks(ts) values ('2014-09-05');
ERROR:  partition on table weeks missing for ts = '2014-09-05'
HINT:  You should call partest.create_for('weeks', '2014-09-05').
insert into weeks(ts) values ('2014-09-06');
insert into weeks(ts) values ('2014-09-12');
insert into weeks(ts) values ('2014-09-13');
insert into weeks(ts) values ('2014-09-19');
insert into weeks(ts) values ('2014-09-20');
ERROR:  partition on table weeks missing for ts = '2014-09-20'
HINT:  You should call partest.create_for('weeks', '2014-09-20').
drop extension pgparts;
