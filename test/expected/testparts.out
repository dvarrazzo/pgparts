create schema partest;
set datestyle = 'ISO';
create extension pgparts with schema partest;
create table sometbl (
    id serial primary key,
    day date not null,
    data text);
select * from partest.info('sometbl', '2014-09-15');
     state     | partition 
---------------+-----------
 unpartitioned | 
(1 row)

select partest.create_for('sometbl', '2014-09-15');
ERROR:  the table sometbl has not been partitioned yet
HINT:  You should call partest.setup('sometbl').
select partest.setup('sometbl'::regclass, 'day', 'monthly', '{3}');
 setup 
-------
 
(1 row)

select * from partest.info('sometbl', '2014-09-15');
  state  | partition 
---------+-----------
 missing | 
(1 row)

-- Setup works once
select partest.setup('sometbl'::regclass, 'day', 'monthly', '{3}');
ERROR:  the table sometbl is already partitioned
HINT:  Use partest.create_for('sometbl', VALUE) to create new partitions on the table.
-- This insert fails
insert into sometbl values (100, '2014-09-15', 'first');
ERROR:  no partition available on table sometbl
HINT:  You should call partest.create_for('sometbl', '2014-09-15')
select * from only sometbl;
 id | day | data 
----+-----+------
(0 rows)

select partest.create_for('sometbl', '2014-09-15');
   create_for   
----------------
 sometbl_201407
(1 row)

select * from partest.info('sometbl', '2014-09-15');
  state  |   partition    
---------+----------------
 present | sometbl_201407
(1 row)

-- Insert
insert into sometbl values (100, '2014-09-15', 'first');
select * from only sometbl;
 id | day | data 
----+-----+------
(0 rows)

select * from only sometbl_201407;
 id  |    day     | data  
-----+------------+-------
 100 | 2014-09-15 | first
(1 row)

-- Update, no partition change
update sometbl set day = '2014-8-15' where id = 100;
select * from only sometbl;
 id | day | data 
----+-----+------
(0 rows)

select * from only sometbl_201407;
 id  |    day     | data  
-----+------------+-------
 100 | 2014-08-15 | first
(1 row)

-- Update to fail partition
update sometbl set day = '2014-10-15' where id = 100;
ERROR:  partition on table sometbl missing for day = '2014-10-15'
HINT:  You should call partest.create_for('sometbl', '2014-10-15')
CONTEXT:  SQL statement "insert into sometbl values (new.*)"
PL/pgSQL function sometbl_partition_update() line 4 at SQL statement
select * from only sometbl;
 id | day | data 
----+-----+------
(0 rows)

select * from only sometbl_201407;
 id  |    day     | data  
-----+------------+-------
 100 | 2014-08-15 | first
(1 row)

-- Create the missing partition and try again
select partest.create_for('sometbl', '2014-10-15');
   create_for   
----------------
 sometbl_201410
(1 row)

update sometbl set day = '2014-10-15' where id = 100;
select * from only sometbl;
 id | day | data 
----+-----+------
(0 rows)

select * from only sometbl_201407;
 id | day | data 
----+-----+------
(0 rows)

select * from only sometbl_201410;
 id  |    day     | data  
-----+------------+-------
 100 | 2014-10-15 | first
(1 row)

-- Detach the partition removes it from writing
insert into sometbl values (104, '2014-07-10', 'third');
select partest.detach_for('sometbl', '2014-07-10');
   detach_for   
----------------
 sometbl_201407
(1 row)

-- Partition is there but removed from the base table
select * from sometbl where day = '2014-07-10';
 id | day | data 
----+-----+------
(0 rows)

select * from sometbl_201407 where day = '2014-07-10';
 id  |    day     | data  
-----+------------+-------
 104 | 2014-07-10 | third
(1 row)

-- Trigger has been maintained
insert into sometbl values (105, '2014-07-10', 'fourth');
ERROR:  partition on table sometbl missing for day = '2014-07-10'
HINT:  You should call partest.create_for('sometbl', '2014-07-10')
insert into sometbl values (106, '2014-10-10', 'fifth');
-- Idempotent
select partest.detach_for('sometbl', '2014-07-10');
   detach_for   
----------------
 sometbl_201407
(1 row)

-- Can't create the same partition again
select partest.create_for('sometbl', '2014-07-10');
ERROR:  the partition sometbl_201407 exists but is detached
HINT:  You can attach it back using partest.attach_for('sometbl', '2014-07-10').
-- But can attach it back
select partest.attach_for('sometbl', '2014-07-10');
   attach_for   
----------------
 sometbl_201407
(1 row)

insert into sometbl values (105, '2014-07-10', 'fourth');
select * from sometbl where day = '2014-07-10' order by id;
 id  |    day     |  data  
-----+------------+--------
 104 | 2014-07-10 | third
 105 | 2014-07-10 | fourth
(2 rows)

-- Idempotent
select partest.attach_for('sometbl', '2014-07-10');
   attach_for   
----------------
 sometbl_201407
(1 row)

drop extension pgparts;
